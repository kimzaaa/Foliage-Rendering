#pragma kernel SpawnGrass

// Terrain dimensions and tile size
float TerrainWidth;
float TerrainHeight;
float TileSize;

// Camera position in world space
float3 CameraPosition;

// Grass blade prefab size
float GrassBladeSize;

// Output buffer for grass blade positions
RWStructuredBuffer<float3> GrassBladePositions;

[numthreads(8, 8, 1)]
void SpawnGrass (uint3 id : SV_DispatchThreadID)
{
    // Calculate the number of tiles in each dimension
    int tilesX = (int)(TerrainWidth / TileSize);
    int tilesZ = (int)(TerrainHeight / TileSize);

    // Calculate the current tile index
    int tileIndex = id.x + id.y * tilesX;

    // Ensure we don't exceed the number of tiles
    if (tileIndex >= tilesX * tilesZ)
        return;

    // Calculate the position of the current tile
    float3 tilePosition = float3(
        (id.x * TileSize) + (TileSize / 2),
        0,
        (id.y * TileSize) + (TileSize / 2)
    );

    // Check if the camera is within this tile
    if (abs(CameraPosition.x - tilePosition.x) <= TileSize / 2 &&
        abs(CameraPosition.z - tilePosition.z) <= TileSize / 2)
    {
        // Generate a 1x1 grid within this tile
        int grassTilesX = (int)(TileSize / GrassBladeSize);
        int grassTilesZ = (int)(TileSize / GrassBladeSize);

        // Calculate the grass blade positions within the 1x1 grid
        for (int gx = 0; gx < grassTilesX; gx++)
        {
            for (int gz = 0; gz < grassTilesZ; gz++)
            {
                float3 grassPosition = float3(
                    tilePosition.x - (TileSize / 2) + (gx * GrassBladeSize) + (GrassBladeSize / 2),
                    0,
                    tilePosition.z - (TileSize / 2) + (gz * GrassBladeSize) + (GrassBladeSize / 2)
                );

                // Store the grass blade position in the output buffer
                int grassIndex = gx + gz * grassTilesX;
                GrassBladePositions[tileIndex * grassTilesX * grassTilesZ + grassIndex] = grassPosition;
            }
        }
    }
}